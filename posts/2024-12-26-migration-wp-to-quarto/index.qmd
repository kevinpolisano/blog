---
title: "Migrer son blog Wordpress vers un blog Quarto statique h√©berg√© gratuitement avec Github Pages"
author: "K√©vin Polisano"
date: "2024-12-26"
categories: [site, quarto]
toc: true
toc-title: "Sommaire"
toc-location: left
reference-location: margin
citation-location: margin
---

Mon site perso fait peau neuve !

Je vous explique ici quelles √©tapes j'ai suivi pour effectuer la migration. Au boulot !

![](wp-to-quarto.jpg)

## Cr√©er son blog avec Quarto

-   Ouvrir `RStudio`
-   Cr√©er un nouveau projet `Create Quarto Blog`
-   Cocher `Create a git repository`

Un [blog Quarto](https://quarto.org/docs/websites/website-blog.html) vierge est ainsi cr√©√© contenant ces fichiers :

-   `_quarto.yml` : Fichier du projet Quarto
-   `index.qmd` : Page d'accueil
-   `about.qmd` : Page "√Ä propos"
-   `posts/` : R√©pertoire contenant les posts en Quarto Markdown (`.qmd`)
-   `posts/_metadata.yml` : Options partag√©es des posts
-   `styles.css` : CSS customis√© pour le style du blog
-   `MyBlog.Rproj` : Raccourci d'ouverture du projet Quarto

Dans le fichier `_quarto.yml` ajouter la ligne `output-dir` pour renseigner le r√©pertoire cible pour la g√©n√©ration du site :

``` yaml
project:
  type: website
  output-dir: docs
```

Enfin pour le g√©n√©rer et avoir le rendu du blog il suffit d'ex√©cuter `build > Render Website`.

## H√©berger son blog avec GitHub pages

### D√©ployer le blog

Apr√®s avoir cr√©√© un nouveau d√©p√¥t sur GitHub √† partir du `.git` local, aller dans `Settings > Pages` puis dans `Build and deployment` et choisir comme source `Deploy from a branch`. Puis s√©lectionner la branche `main` et le dossier `/docs` avant de valider avec `save`. Apr√®s quelques minutes le lien vers la page du blog est g√©n√©r√© : `kevinpolisano.github.io`

### Nom de domaine customis√©

L'h√©bergeur de mon site WP √©tait [o2switch](https://www.o2switch.fr/), que je recommande pour la grande r√©activit√© de leur service technique.

**Du c√¥t√© de ce registar** voici les √©tapes √† suivre :

-   Dans `Espace client > Commander un service` choisir `Commander un nom de domaine` (pour ma part : `kevinpolisano.fr`)
-   Dans `Espace technique > Domaines configur√©s` remplir `Configurer un nom de domaine` (pour ma part : `kevinpolisano.fr`) puis activer `Let's Encrypt SSL` dans l'onglet `S√©curit√©` du cPanel.
-   Dans `Espace technique > Zone Editor` entrer les champs suivants (√† adapter selon le blog) :\

| Nom                   | TLL   | Type  | Enregistrement          |
|-----------------------|-------|-------|-------------------------|
| www.kevinpolisano.fr. | 14400 | CNAME | kevinpolisano.github.io |
| kevinpolisano.fr.     | 14400 | A     | 185.199.108.153         |
| kevinpolisano.fr.     | 14400 | A     | 185.199.109.153         |
| kevinpolisano.fr.     | 14400 | A     | 185.199.110.153         |
| kevinpolisano.fr.     | 14400 | A     | 185.199.111.153         |

-   J'ai √©galement cr√©√© un fichier `CNAME` √† la racine du d√©p√¥t git, contenant la ligne `www.kevinpolisano.fr`.

**Du c√¥t√© de GitHub Pages** voici les √©tapes √† suivre :

-   Dans `Custom Domain` renseigner le nouveau nom de domaine `www.kevinpolisano.fr` puis cliquer sur `save`. √Ä ce stade j'ai obtenu √† tour de r√¥le les messages d'erreurs suivants :

::: callout-important
DNS check unsuccessful

Both kevinpolisano.fr and its alternate name are improperly configured Domain does not resolve to the GitHub Pages server. For more information, see documentation (NotServedByPagesError).
:::

::: callout-warning
DNS valid for primary

kevinpolisano.fr is improperly configured Domain does not resolve to the GitHub Pages server. For more information, see documentation (NotServedByPagesError).
:::

-   J'ai du attendre quelques heures pour que la propagation du DNS soit effective. On peut suivre celle-ci sur [DNS Checker](https://dnschecker.org/) en s'assurant pour le domaine racine `kevinpolisano.fr` que les enregistrements `A` pointent vers les IP GitHub Pages; et pour le sous-domaine `www.kevinpolisano.fr` que l'enregistrement `CNAME` pointe vers `kevinpolisano.github.io`.

-   Une fois que le bouton `save` donne `DNS check successful` on coche `Enforce HTTPS` et on v√©rifie qu'en tapant `kevinpolisano.fr` dans la barre de navigateur on est bien redirig√© vers le blog √† l'adresse `https://www.kevinpolisano.fr/`

## Exporter ses articles Wordpress en HTML vers Markdown

J'ai exp√©riment√© trois solutions :

1.  [GitHub - SchumacherFM/wordpress-to-hugo-exporter](https://github.com/SchumacherFM/wordpress-to-hugo-exporter)
2.  [GitHub - lonekorean/wordpress-export-to-markdown](https://github.com/lonekorean/wordpress-export-to-markdown)
3.  [GitHub - palaniraja/blog2md](https://github.com/palaniraja/blog2md)

La premi√®re conserve certaines balises HTML (typiquement pour l'usage de la couleur et la mise en forme), tandis que les deux suivantes exportent en pur Markdown.

### Wordpress to Hugo Exporter

La premi√®re solution consiste √† *uploader* l'archive sur le site WP dans le dossier `wp-content/plugins` √† activer le plugin et utiliser `Outils > Export Hugo`. Ce dernier n'a pas fonctionn√© donc j'ai utilis√© le Terminal de mon serveur d'h√©bergement (O2switch) (comme expliqu√© [ici](file:///Users/polisank/Zotero/storage/ERLHNLWT/jai-enfin-migre-de-wordpress-a-hugo-partie-2.html)) :

``` bash
cd wp-content/plugins/wordpress-to-hugo-exporter/
php hugo-export-cli.php
```

Le script cr√©√© un fichier `/tmp/wp-hugo.zip` (cela peut prendre quelques minutes). Dans le gestionnaire de fichiers (*via* le Cpanel d'O2switch) j'ai effectu√© une recherche du fichier, qui m'a indiqu√©e que celui-ci se trouvait dans le dossier cach√© `.cagefs/tmp/`.

### Wordpress export to Markdown

Premi√®rement on effectue un export du contenu complet de WP au format `export.xml` (dans `Outils > Exporter`), que l'on place dans l'archive du code t√©l√©charg√©. Puis on ex√©cute le script :

``` bash
npm install && node index.js
```

### Blog2md

De m√™me on ex√©cute :

``` bash
npm install && node index.js w export.xml out
```

## Nettoyage des articles export√©s, liens, images, ...

Lorsque mes billets WP contenaient du texte brut, du code ou du $\LaTeX$, j'ai utilis√© l'export Markdown de `Wordpress export to Markdown`; tandis que pour mes billets contenant une mise en forme travaill√©e (avec notamment l'usage de couleurs), j'ai utilis√© l'export Markdown + HTML de `Wordpress to Hugo Exporter`, qui a aussi le bon go√ªt d'exporter toutes les images dans `wp-content/uploads/`. Pour ces fichiers Markdown + HTML, j'ai √©crit un script Python permettant entre autres de :

-   Remplacer les liens HTML par des liens Markdown, pour les images en particulier par l‚Äôinsertion de `![](images/img)` en ayant pr√©alablement copi√© l‚Äôimage courante `img` (priv√©e de sa dimension) du dossier `uploads/` vers le dossier `images/`du r√©pertoire courant correspondant au billet.
-   Remplacer les footnotes HTML par des footnotes Markdown.
-   Remplacer les blocs de code HTML par des balises de code Markdown (ici pr√©cisant le language Matlab)

``` python
import re
import os
import shutil

# Dossiers source et destination pour les images
UPLOADS_DIR = "../uploads"
IMAGES_DIR = "images"
INPUT_FILE = "index_prev.qmd"
OUTPUT_FILE = "index.qmd"

# Cr√©er le dossier images s'il n'existe pas
if not os.path.exists(IMAGES_DIR):
    os.makedirs(IMAGES_DIR)

# Lire le fichier d'entr√©e
with open(INPUT_FILE, "r", encoding="utf-8") as file:
    content = file.read()

# Fonction pour traiter les images
def process_images(content):
    image_pattern = re.compile(
        r'<a [^>]*?href="[^"]*?/([^/"]+)"[^>]*?><img [^>]*?src="[^"]*?/([^/"]+)"[^>]*?></a>'
    )
    
    def replace_image(match):
        image_file = match.group(1)
        base_name, ext = os.path.splitext(image_file)
        
        # V√©rifier si le nom contient les dimensions WxH
        dimension_pattern = re.compile(r"^(?P<name>.+)-\d+x\d+$")
        dimension_match = dimension_pattern.match(base_name)
        
        if dimension_match:
            base_name = dimension_match.group("name")  # Nom sans dimensions
            original_image_file = base_name + ext
            original_path = os.path.join(UPLOADS_DIR, original_image_file)
            
            # Si l'image sans dimensions existe, utiliser celle-ci
            if os.path.exists(original_path):
                image_file = original_image_file
        
        # Copier l'image
        src_path = os.path.join(UPLOADS_DIR, image_file)
        dest_path = os.path.join(IMAGES_DIR, image_file)
        if os.path.exists(src_path):
            shutil.copy2(src_path, dest_path)
        
        return f"![](images/{image_file})"
    
    return image_pattern.sub(replace_image, content)

# Fonction pour traiter les blocs de code
def process_code_blocks(content):
    code_block_pattern = re.compile(
        r'<pre class="brush:[^"]+">(.*?)</pre>', re.DOTALL
    )
    
    def replace_code_block(match):
        code_content = match.group(1).replace("&gt;", ">").replace("&lt;", "<").replace("&amp;", "&")
        return f"```matlab\n{code_content}\n```"
    
    return code_block_pattern.sub(replace_code_block, content)

# Fonction pour traiter les footnotes
def process_footnotes(content):
    footnote_body_pattern = re.compile(
        r'<sup id="(?P<id>[^"]+)"><a href="#[^"]+" title="(?P<title>[^"]+)"[^>]*>\d+</a></sup>'
    )
    
    def replace_footnote_body(match):
        footnote_id = match.group("id")
        footnote_content = match.group("title").replace("&#039;", "'").replace("&quot;", '"')
        markdown_footnote = f"[^{footnote_id}]"
        markdown_definition = f"[^{footnote_id}]: {footnote_content}"
        return markdown_footnote, markdown_definition
    
    paragraphs = content.split("\n\n")  # Diviser en paragraphes
    updated_paragraphs = []
    
    for paragraph in paragraphs:
        matches = list(footnote_body_pattern.finditer(paragraph))
        if matches:
            definitions = []
            for match in matches:
                footnote_markdown, footnote_definition = replace_footnote_body(match)
                paragraph = paragraph.replace(match.group(0), footnote_markdown)
                definitions.append(footnote_definition)
            updated_paragraphs.append(paragraph)
            updated_paragraphs.extend(definitions)
        else:
            updated_paragraphs.append(paragraph)
    
    return "\n\n".join(updated_paragraphs)

# Fonction pour supprimer les balises <li id=X>
def remove_list_items(content):
    list_item_pattern = re.compile(r'<li id="[^"]+">.*?</li>', re.DOTALL)
    return list_item_pattern.sub("", content)

# Fonction pour supprimer l‚Äôindentation des balises de paragraphes
def remove_paragraph_indentation(content):
    paragraph_pattern = re.compile(r"\s*<(/?p)>")
    return paragraph_pattern.sub(r"<\1>", content)

# Appliquer les transformations
content = process_images(content)
content = process_code_blocks(content)
content = process_footnotes(content)
content = remove_list_items(content)
content = remove_paragraph_indentation(content)

# √âcrire le fichier de sortie
with open(OUTPUT_FILE, "w", encoding="utf-8") as file:
    file.write(content)

print(f"Transformation termin√©e. R√©sultat enregistr√© dans {OUTPUT_FILE}.")
```

Bien s√ªr j'ai aussi modifi√© les exports √† la main lorsque je rep√©rais des rectifications ponctuelles (non automatisables). L'export en pur Markdown a quant √† lui le bon go√ªt de renseigner les liens cass√©s, ce qui permet au passage de faire un nettoyage des [liens morts](https://fr.wikipedia.org/wiki/Lien_mort) t√©moins du pourrissement des liens du web. √Ä l'avenir, je vais t√¢cher de privil√©gier la bibliographie (`.bib`) renseignant les m√©tadonn√©es des sources (titre, journal, date, ...) pour que celles-ci restent identifiables en cas de liens morts, et donc potentiellement trouvables ailleurs si l'article a √©t√© h√©berg√© √† une autre adresse.

## Gestion des commentaires

J'ai opt√© pour [giscus](https://giscus.app/fr), qui est un dispositif relativement l√©ger, bas√© sur les discussions GitHub, open-source et sans publicit√©. Le seul b√©mol est qu'il faut disposer d'un compte Github pour √™tre autoris√© √† commenter. L'avantage par ailleurs est que l'on est moins sujet aux spams et aux commentaires injurieux (l'authentification, plus co√ªteuse en temps, en dissuadent plus d'un).

### Mise en place de la fonctionnalit√©

Pour activer les commentaires il faut remplir la [page giscus](https://giscus.app/fr) d√©taillant la marche √† suivre :

- Installer [l'application giscus](https://github.com/apps/giscus)
- Activer les [discussions Github](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository) dans l'onglet `Settings > Features` du d√©p√¥t en cochant la case `Discussions`.
- Renseigner le d√©p√¥t public (dans mon cas `kevinpolisano/blog`) ainsi que les propri√©t√©s escompt√©es.

La balise HTML g√©n√©r√©e est la suivante dans mon cas :

```html
<script src="https://giscus.app/client.js"
        data-repo="kevinpolisano/blog"
        data-repo-id="R_kgDOM9ReCA"
        data-category="Announcements"
        data-category-id="DIC_kwDOM9ReCM4CmGgm"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="fr"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
```

Ce qui me permet de remplir les options de commentaires dans le fichier `_quarto.yml` comme suit :

```yaml
project:
  type: website
  output-dir: docs

website:
  title: "Blog de K√©vin Polisano"
  navbar:
    right:
      - about.qmd
  comments:
    giscus:
      repo: "kevinpolisano/blog"
      repo-id: "R_kgDOM9ReCA"
      category: "Announcements"
      category-id: "DIC_kwDOM9ReCM4CmGgm"
      mapping: "pathname"
      reactions-enabled: true
      input-position: "bottom"
      theme: "light"
      language: "fr"
      loading: "lazy"
format:
  html:
    theme: flatly
    css: styles.css

editor: visual
```

### Extraction des commentaires Wordpress

On commence par extraire les commentaires dans un fichier `comments.csv` √† partir de `export.xml` gr√¢ce √† ce script python qui *parse* les commentaires :

```python
import xml.etree.ElementTree as ET
import csv

# Chemin vers le fichier XML export√©
xml_file = "export.xml"
output_file = "comments.csv"

# Charger le fichier XML
tree = ET.parse(xml_file)
root = tree.getroot()

# Namespace de WordPress
ns = {"wp": "http://wordpress.org/export/1.2/"}

# Extraire les commentaires
comments = []
for item in root.findall(".//item"):
    post_title = item.find("title").text
    post_url = item.find("link").text
    for comment in item.findall("wp:comment", ns):
        author = comment.find("wp:comment_author", ns).text
        content = comment.find("wp:comment_content", ns).text
        date = comment.find("wp:comment_date", ns).text
        comments.append([post_title, post_url, author, content, date])

# √âcrire dans un fichier CSV
with open(output_file, "w", newline="", encoding="utf-8") as f:
    writer = csv.writer(f)
    writer.writerow(["Post Title", "Post URL", "Author", "Comment", "Date"])
    writer.writerows(comments)

print(f"Commentaires export√©s dans {output_file}")
```
  
### Cr√©ation d'un Token GitHub

Voici les √©tapes pour cr√©er un token personnel GitHub avec l'autorisation pour g√©rer les discussions (comme les commentaires pour Giscus) :

- Allez dans `Settings > Developer Settings` (g√©n√©ral pas dans un d√©p√¥t) puis `Personal access tokens > Tokens (classic)`.
- S√©lectionnez `Generate new token > Generate new token (classic)`.
- Donnez un nom au token : `Giscus Discussions Token`.
- D√©finissez une dur√©e d‚Äôexpiration : choisissez une dur√©e (par exemple 30 jours) ou No expiration pour un usage prolong√©.
- S√©lectionnez les autorisations n√©cessaires :
  - `public_repo` : Acc√©der aux d√©p√¥ts publics
  - `read:discussion` : Lire les discussions.
  - `write:discussion` : Ajouter ou modifier des discussions.
- G√©n√©rer et sauvegarder le token (par exemple, un gestionnaire de mots de passe)
- Dans les param√®tres de votre projet o√π Giscus est configur√©, ajoutez le token comme variable d'environnement dans `Settings > Secrets and variables > Actions` avec le nom `GH_TOKEN` (ou un autre nom significatif) et collez le token.

### Cr√©ation des discussions

Voici un script Python qui utilise l'API `graphql` pour cr√©er automatiquement toutes les discussions avec les titres correspondant au `pathname` (pour √™tre raccord avec `mapping: pathname` dans `_quarto.yml`).

```python
import os
import requests

# üîπ Configuration
GITHUB_TOKEN = "ghp_"  # Remplacez par votre token GitHub
REPO_OWNER = "kevinpolisano"  # Votre nom d'utilisateur GitHub
REPO_NAME = "blog"  # Nom du d√©p√¥t GitHub
CATEGORY_ID = "DIC_kwDOM9ReCM4CmGgm"  # ID de la cat√©gorie des discussions
POSTS_DIR = "/posts/"  # Dossier contenant vos articles Quarto

GITHUB_GRAPHQL_URL = "https://api.github.com/graphql"

# üîπ Fonction pour envoyer une requ√™te GraphQL
def send_graphql_query(query, variables=None):
    headers = {
        "Authorization": f"Bearer {GITHUB_TOKEN}",
        "Content-Type": "application/json",
    }
    payload = {"query": query, "variables": variables}
    response = requests.post(GITHUB_GRAPHQL_URL, json=payload, headers=headers)
    response.raise_for_status()
    return response.json()

# üîπ V√©rifie si une discussion existe d√©j√† pour un post
def discussion_exists(title):
    query = """
    query($owner: String!, $name: String!) {
        repository(owner: $owner, name: $name) {
            discussions(first: 100) {
                nodes {
                    title
                }
            }
        }
    }
    """
    variables = {"owner": REPO_OWNER, "name": REPO_NAME}
    result = send_graphql_query(query, variables)
    discussions = result.get("data", {}).get("repository", {}).get("discussions", {}).get("nodes", [])

    return any(d["title"] == title for d in discussions)


def get_repository_id():
    query = """
    query($owner: String!, $name: String!) {
        repository(owner: $owner, name: $name) {
            id
        }
    }
    """
    variables = {"owner": REPO_OWNER, "name": REPO_NAME}
    result = send_graphql_query(query, variables)
    return result.get("data", {}).get("repository", {}).get("id", None)


# üîπ Cr√©e une discussion pour un post donn√©
def create_discussion(title, repository_id):
    mutation = """
    mutation($title: String!, $body: String!, $categoryId: ID!, $repositoryId: ID!) {
        createDiscussion(input: {title: $title, body: $body, categoryId: $categoryId, repositoryId: $repositoryId}) {
            discussion {
                id
                title
                url
            }
        }
    }
    """
    variables = {
        "title": title,
        "body": "Discussion for this post",
        "categoryId": CATEGORY_ID,
        "repositoryId": repository_id
    }
    
    print(f"üîπ Tentative de cr√©ation de la discussion pour : {title}")
    
    result = send_graphql_query(mutation, variables)
    print("üîç R√©ponse GitHub :", result)  # Debugging

    if "errors" in result:
        print(f"‚ùå √âchec : {result['errors']}")
    else:
        discussion = result.get("data", {}).get("createDiscussion", {}).get("discussion", {})
        if discussion:
            print(f"‚úÖ Discussion cr√©√©e : {discussion['title']} ({discussion['url']})")
        else:
            print(f"‚ùå √âchec de la cr√©ation pour {title}")


# üîπ Parcours des fichiers posts/ et cr√©ation des discussions
if __name__ == "__main__":
    repository_id = get_repository_id()
    if not repository_id:
        print("‚ùå Impossible de r√©cup√©rer l'ID du d√©p√¥t. V√©rifie ton token et le nom du repo.")
        exit(1)

    for folder in os.listdir(POSTS_DIR):
        post_path = os.path.join(POSTS_DIR, folder)
        if os.path.isdir(post_path):  # V√©rifie que c'est bien un dossier
            title = f"posts/{folder}/"
            if discussion_exists(title):
                print(f"üîπ Discussion d√©j√† existante pour : {title}")
            else:
                print(f"üìå Cr√©ation de la discussion pour : {title}")
                create_discussion(title, repository_id)
```

√Ä noter que j'ai du d√©j√† faire appara√Ætre en d√©filant la section commentaire en local (avec `quarto preview`) pour chaque post afin que le fichier `html` contienne la portion de code suivante :

```html
<script src="https://giscus.app/client.js" 
data-repo="kevinpolisano/blog" 
data-repo-id="R_kgDOM9ReCA" 
data-category="Announcements" 
data-category-id="DIC_kwDOM9ReCM4CmGgm" 
data-mapping="pathname" 
data-reactions-enabled="1" 
data-emit-metadata="0" 
data-input-position="bottom" 
data-theme="light" 
data-lang="fr" 
crossorigin="anonymous" 
data-loading="lazy" async="">
</script> 
```

<!-- ## Conclusion -->

<!-- La seule inqui√©tude que j'ai concerne l'espace de stockage. -->
